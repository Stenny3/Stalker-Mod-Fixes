config = ini_file_ex("warfare_options.ltx", true)

options = {}
saved = {}

-- setup_options will set this to false, rw will set this to true if saving is required, and then setup_options will save it.
need_save = false

function get_saved(var, typ)
	if not (saved[var]) then
		return nil
	end
	
	local v = saved[var]
	
	if (typ == 1) then
		v = v == "true"
	elseif (typ == 2) then
		v = tonumber(v)
	end
	
	--printf("returning " .. var .. "=" .. tostring(v))
	
	return v
end

-- function to help cut down on typing with reading warfare variables
function rw(var, typ, def)
	if not (config:line_exist("warfare_options", var)) then
		--printf("NEED SAVE FOR " .. var)
		need_save = true
	end
	
	return get_saved(var, typ) or config:r_value("warfare_options", var, typ, def)
end

-- function to help cut down on typing with writing warfare variables
function ww(var, val)
	config:w_value("warfare_options", var, val)
end

-- Will want to cycle through each variable to ensure it exists within
-- warfare_options.ltx, or set it to defaults
function setup_options()	
	printf("setup")

	need_save = false
	options.factions = {}
    options.factions.monster = {}
																										
    options.simulate_offline_combat_at_smarts 		= rw("simulate_offline_combat_at_smarts", 1, false) 
	options.disable_offline_combat					= rw("disable_offline_combat", 1, false)            
	options.random_starting_locations				= rw("random_starting_locations", 1, false)
	options.random_starting_character				= rw("random_starting_character", 1, false)
	options.random_stalker_chance					= rw("random_stalker_chance", 2, 50)
	options.random_monster_chance					= rw("random_monster_chance", 2, 50)
	--options.disable_linked_levels 					= rw("disable_linked_levels", 1, false)             
	options.hide_smarts								= rw("hide_smarts", 1, false)
	options.fog_of_war								= rw("fog_of_war", 1, true)
	options.fog_of_war_distance						= rw("fog_of_war_dist", 2, 100)
--xQd	
	options.enemy_new_game_bonus					= rw("enemy_new_game_bonus", 1, true)
	options.disable_smart_pop_cap					= rw("disable_smart_pop_cap", 1, false)
--xQd
	
	options.enable_auto_capture						= rw("enable_auto_capture", 1, true)
	options.auto_capture_max_distance				= rw("auto_capture_max_distance", 2, 50)
	options.auto_capture_wait_time					= rw("auto_capture_wait_time", 2, 15)				

--av661194
	options.hide_undegraund_smarts 					= rw("hide_undegraund_smarts", 1, true)            
--av661194
	options.hide_unfriendly_squads 					= rw("hide_unfriendly_squads", 1, true)            
	options.enable_mutant_offline_combat 			= rw("enable_mutant_offline_combat", 1, true)       
	
	options.randomize_squad_count					= rw("randomize_squad_count", 1, false)             
	options.min_squad_count							= rw("min_squad_count", 2, 1)                       
	options.max_squad_count							= rw("max_squad_count", 2, 2)                       
	
	options.enemy_resource_boost					= rw("enemy_resource_boost", 2, 0)
	options.enemy_base_boost						= rw("enemy_base_boost", 2, 0)

	options.actor_support_enemy_rank_weight 		= rw("actor_support_enemy_rank_weight", 2, 0)       
	options.actor_support_reward_money				= rw("actor_support_reward_money", 2, 500)          
	options.actor_support_reward_influence			= rw("actor_support_reward_influence", 2, 0.2)      
	options.actor_influence_weight 					= rw("actor_influence_weight", 2, 1)                
    options.debug_logging                           = rw("debug_logging", 1, false)                     
	options.monster_min_faction_respawn 			= rw("monster_min_faction_respawn", 2, 5)           
	options.monster_max_faction_respawn 			= rw("monster_max_faction_respawn", 2, 30)          
    options.monster_max_squads_per_level      		= rw("monster_max_squads_per_level", 2, 5)          
	options.all_out_war 							= rw("all_out_war", 1, false)                       
	options.factions_keep_last_base 				= rw("factions_keep_last_base", 1, false)           
	options.novice_squad_price 						= rw("novice_squad_price", 2, 1000)                 
	options.advanced_squad_price 					= rw("advanced_squad_price", 2, 10000)              
	options.veteran_squad_price 					= rw("veteran_squad_price", 2, 50000)               
	options.heli_price 								= rw("heli_price", 2, 75000)                        
	options.zombies_act_as_faction 					= rw("zombies_act_as_faction", 1, false)            
    options.zombie_mode                             = rw("zombie_mode", 1, false)                        
	options.enable_offline_news 					= rw("enable_offline_news", 1, false)               
	options.offline_news_display_percentage			= rw("offline_news_display_percentage", 2, 10)      

	-- For each min/max set, the factions current value will be calculated
	-- by interpolating between min and max using owned_resources/total_resources
	-- as the factor. This may change for some sets; for instance, min_patrol_squads
	-- and max_patrol_squads should probably be based on (current_resources+current_bases)/(total_resources+total_bases).	
	for i,faction in pairs(warfare_factions.factions) do
		options.factions[faction] = {}
		options.factions[faction].participate_in_warfare	 	= rw(faction.."_".."participate_in_warfare", 1, true)
		options.factions[faction].random_patrols			= rw(faction.."_".."random_patrols", 1, false)

		options.factions[faction].random_squad_count			= rw(faction.."_".."random_squad_count", 1, false)
		options.factions[faction].min_random_squad_count		= rw(faction.."_".."min_random_squad_count", 2, 1)
		options.factions[faction].max_random_squad_count		= rw(faction.."_".."max_random_squad_count", 2, 3)

		options.factions[faction].min_faction_respawn 			= rw(faction.."_".."min_faction_respawn", 2, 15)             
		options.factions[faction].max_faction_respawn 			= rw(faction.."_".."max_faction_respawn", 2, 90)             
		options.factions[faction].base_population_mult			= rw(faction.."_".."base_population_mult", 2, 1)
		options.factions[faction].resource_population_mult		= rw(faction.."_".."resource_population_mult", 2, 1)
		options.factions[faction].min_invasion_size				= rw(faction.."_".."min_invasion_size", 2, 1.0)				 
		options.factions[faction].max_invasion_size				= rw(faction.."_".."max_invasion_size", 2, 2.5)				 
		options.factions[faction].invasion_departure_chance		= rw(faction.."_".."invasion_departure_chance", 2, 100)
		options.factions[faction].min_active_squads 			= rw(faction.."_".."min_active_squads", 2, 3)                
		options.factions[faction].max_active_squads 			= rw(faction.."_".."max_active_squads", 2, 15)               
		options.factions[faction].min_patrol_squads 			= rw(faction.."_".."min_patrol_squads", 2, 5)                
		options.factions[faction].max_patrol_squads 			= rw(faction.."_".."max_patrol_squads", 2, 5)                
		options.factions[faction].min_patrol_time				= rw(faction.."_".."min_patrol_time", 2, 5)					 
		options.factions[faction].max_patrol_time				= rw(faction.."_".."max_patrol_time", 2, 5)				
		options.factions[faction].patrol_hunt_chance			= rw(faction.."_".."patrol_hunt_chance", 2, 50)	 
		options.factions[faction].min_patrol_idle_time			= rw(faction.."_".."min_patrol_idle_time", 2, 15)			 
		options.factions[faction].max_patrol_idle_time			= rw(faction.."_".."max_patrol_idle_time", 2, 60)		     
		options.factions[faction].base_count_modifier			= rw(faction.."_".."base_count_modifier", 2, 0)
		options.factions[faction].resource_count_modifier		= rw(faction.."_".."resource_count_modifier", 2, 0)
		options.factions[faction].offline_power_multiplier 		= rw(faction.."_".."offline_power_multiplier", 2, 1)         
		options.factions[faction].expansion_aggression 			= rw(faction.."_".."expansion_aggression", 2, 50)            
		options.factions[faction].resurgence_chance 			= rw(faction.."_".."resurgence_chance", 2, 50)               
		options.factions[faction].max_active_squads_per_target 	= rw(faction.."_".."max_active_squads_per_target", 2, 1)     
		options.factions[faction].max_smart_targets_per_base	= rw(faction.."_".."max_smart_targets_per_base", 2, 2)       
		options.factions[faction].base_priority                 = rw(faction.."_".."base_priority", 2, 3)                    
		options.factions[faction].resource_priority             = rw(faction.."_".."resource_priority", 2, 1)                
		options.factions[faction].territory_priority			= rw(faction.."_".."territory_priority", 2, 0)				 
		options.factions[faction].faction_flag_priority         = rw(faction.."_".."flag_priority", 2, 2)                    
		options.factions[faction].is_being_targeted_priority    = rw(faction.."_".."is_being_targeted_priority", 2, 2)           
		options.factions[faction].target_weaker_priority        = rw(faction.."_".."target_weaker_priority", 2, 1)           
		options.factions[faction].target_stronger_priority      = rw(faction.."_".."target_stronger_priority", 2, -1)        
		options.factions[faction].target_on_same_level_priority = rw(faction.."_".."target_on_same_level_priority", 2, 15)
		options.factions[faction].night_activity_chance 		= rw(faction.."_".."night_activity_chance", 2, 25)
		options.factions[faction].resource_count_modifier 		= rw(faction.."_".."resource_count_modifier", 2, 0)
		options.factions[faction].base_count_modifier			= rw(faction.."_".."base_count_modifier", 2, 0)            
	end
	
	if (need_save) then
		save_options(true)
	end

	
	if (options.all_out_war) then
		warfare.need_all_out_war_applied = true
	end

	printf("end setup")
end

function save_options(skip_setup)
	for k,v in pairs(options) do
		local t = type(v)
		
		if (t == "string" or t == "boolean" or t == "number") then
			config:w_value("warfare_options", k, v)
			saved[k] = v
		else
			--printf("not saving..." .. tostring(t) .. "|" .. tostring(k) .. "|" .. tostring(v))
		end
	end
	
	for _,f in pairs(warfare_factions.factions) do
		for k,v in pairs(options.factions[f]) do
			config:w_value("warfare_options", f.."_"..k, v)
			saved[f.."_"..k] = v
			--printf(f.."_"..k.."="..v)
		end
	end
	
	config:save()
	
	if not (skip_setup) then
		-- variables are saved as strings, setup_options() will go through and reload them
		setup_options()
	end
end

ENABLE_MUTANT_OFFLINE_COMBAT = true

-- when true, offline combat will only simulate when squads reach their targets.
-- This will have the faction wars update more quickly typically and likely offer greater stability, but at the expense of making it
-- harder to hold territory.
SIMULATE_OFFLINE_COMBAT_AT_SMARTS = false

-- disable the offline combat simulator; this will lead to the faction wars primarily updating around the player.
-- recommend using large alife distance if you do this. will likely lead to a slower paced and easier faction war for the player.
DISABLE_OFFLINE_COMBAT = false

-- TODO:
-- Show all smarts. None = gray, neutral = yellow, enemy = red, friend = green, ally = blue?
SHOW_ALL_SMARTS = false

-- Show all squads. Neutral = yellow, enemy = red, friend = green
SHOW_ALL_SQUADS = false

RANDOMIZE_SQUAD_COUNT = false
SQUAD_COUNT_MIN = 2
SQUAD_COUNT_MAX = 4

function init(menu)
	menu.OnButton_warfare_options_clicked = function()
		setup_options()
	
		if menu.wf_opt_dlg == nil then
			menu.wf_opt_dlg = ui_warfare_options_new.warfare_options_new()
			menu.wf_opt_dlg.owner = menu
		end
		
		menu.wf_opt_dlg:ShowDialog(true)
		
		menu:HideDialog()
		menu:Show(false)
	end
	
	menu.OnButton_warfare_options_adv_clicked = function()
		if menu.wf_opt_adv_dlg == nil then
			menu.wf_opt_adv_dlg = ui_warfare_options_advanced.warfare_advanced_dialog()
			menu.wf_opt_adv_dlg.owner = menu
		end
		
		menu.wf_opt_adv_dlg:ShowDialog(true)
		
		menu:HideDialog()
		menu:Show(false)
	end
	menu:AddCallback("btn_warfare_options_adv", ui_events.BUTTON_CLICKED, menu.OnButton_warfare_options_adv_clicked, menu)

	menu:AddCallback("btn_warfare_options", ui_events.BUTTON_CLICKED, menu.OnButton_warfare_options_clicked, menu)
end


function override_functions()	
	heli_alife.update = heli_alife_warfare.update
	heli_alife.force_target_destination = heli_alife_warfare.force_target_destination
end

function get_random_start_location()
	start_table = {}
	local loc_ini = ini_file("plugins\\player_start_locations.ltx")
					
	local n = 0
	
	for i,f in pairs(warfare_factions.factions) do
		n = loc_ini:line_count(f.."_start_locations") or 0
		
		for i=0,n-1 do
			local result, id, value = loc_ini:r_line(f.."_start_locations", i, "", "")
			table.insert(start_table, id)
		end
	end
	
	start_location = start_table[math.random(#start_table)]
	
	return start_location
end

function ui_mm_faction_select.faction_ui.OnStartGame(self)
	-- start game anyway if no config or axr_main script
	if not (axr_main and axr_main.config) then
		self.owner:StartGame()
		return
	end

	local character_name = self.character_name:GetText()
	if (character_name == "") then
		-- Require a name to be entered.
		return
	end

	if (self.start_list:CurrentID() <= 0) then
		local index = math.random(1,#self.start_table)
		self.start_location = self.start_table[index]
--		self.start_list:SetText(game.translate_string("ui_st_"..self.start_table[index]))
	end
	
	if (warfare_options.options.random_starting_locations) then
		self.start_location = get_random_start_location()	
	end	

	axr_main.config:w_value("character_creation","new_game_hardcore_mode",self.ck_hardcore and self.ck_hardcore:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_story_mode",self.ck_story and self.ck_story:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_azazel_mode",self.ck_azazel_mode and self.ck_azazel_mode:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_survival_mode",self.ck_survival and self.ck_survival:GetCheck() and true or nil)
	axr_main.config:w_value("character_creation","new_game_faction",self.selected_faction or nil)
	axr_main.config:w_value("character_creation","new_game_faction_position",self.start_location or nil)
	axr_main.config:w_value("character_creation","new_game_loadout",self.loadout_str or nil)
	axr_main.config:w_value("character_creation","new_game_character_icon",self.icon_list:GetText())

	-- Store info in temp config so it can be read on next game load
	axr_main.config:w_value("character_creation","new_game_character_name", character_name:gsub(" ","_") )
	axr_main.config:save()

	-- Start the game
	self.owner:StartGame()
end

function sim_squad_scripted.sim_squad_scripted.check_online_status(self)
	local b = nil
	
	if (IsSurvivalMode()) then
		b = true
	elseif (self.force_online) then
		b = true
	elseif (axr_companions.companion_squads[self.id]) then 
		b = true
	elseif not (level_weathers.valid_levels[level.name()]) then -- force online in underground levels
		b = true
	elseif (self.assigned_target_id and is_squad_monster[self.player_id]) then
			local hour = level.get_time_hours()
			if (self.player_id == "monster_predatory_day") then 
				-- Monster will not come online during the hours of (9PM till 5AM)
				if (hour <= 5 or hour >= 22) then
					b = false 
				end
			elseif (self.player_id == "monster_zombied_day") then 
				-- Monster will not come online during the hours of (7PM till 5AM)
				if (hour <= 5 or hour >= 19) then
					b = false
				end
			elseif (self.player_id == "monster_predatory_night") then 
				-- Monster will not come online during the hours of (5AM till 7PM)
				if (hour >= 5 and hour <= 19) then
					b = false
				end
			elseif (self.player_id == "monster_zombied_night") then 
				-- Monster will not come online during the hours of (5AM till 7PM)
				if (hour >= 5 and hour <= 19) then
					b = false
				end
			end																			 
	elseif (db.actor and not get_object_story_id(self.id) and not self.online) then	-- exclude from coming online except if already online or storied			 
		local dist = axr_main.config:r_value("mm_options","excl_dist",2) or 0
		if (dist > 0 and not db.actor:has_info("actor_is_sleeping")) then 
			local actor = alife():actor()
			if (self.position:distance_to(actor.position) <= dist) then
				b = false
			end
		end
	end
	self.forced_online_status = b
end
